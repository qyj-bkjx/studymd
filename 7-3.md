## static 

C++里面静态变量有三种: 分别是外部链接性,内部链接性和无链接性.

声明外部链接的变量的方法是在代码块外面声明它. 此变量是全局变量,多文件中亦可用.

声明内部链接的变量的方法是在代码块外面声明它并加上static限定符. 此变量是全局变量,但仅在本文件中可用.

声明无链接的变量的方法是在代码块里面声明它并加上static限定符. 此变量是局部变量,但仅在本代码块中可用.

静态数据成员：所有类实体共享

静态成员函数：只能使用静态数据成员

## 拷贝

浅拷贝：不复制对象本身，只是复制指向某个对象的指针，共享内存，一个析构，另一个析构会导致两次free同一个对象

深拷贝：复制对象

对于只有一层结构的对象拷贝一个副本时，使用浅拷贝，对于含有指针的对象使用深拷贝

## 友元
全局函数做友元

类做友元

成员函数做友元
~~~
class bro{};
class a{
    friendly void bro::visit();
};
~~~
## 继承方式
公共/保护/私有

不变/公有变保护/公有保护变私有（私有都不可访问）
### 菱形继承

两个父类虚继承，各包含一个虚基类指针，做到只保留一份数据

## 多态
函数重载和运算符重载属于静态多态

静态函数地址早绑定

动态函数地址晚绑定
### 虚函数
基类使用虚函数，传入子类函数执行函数取决于虚函数有没有被重写，根据传入不同子类执行不同函数。

vfptr指向vftable，虚函数表内记录虚函数地址，重写虚函数时，子类虚表内部将替换子类的虚函数地址。

### 纯虚函数
必须重写的虚函数（实现部分改为"=0"），除非子类重写，否则无法实例化
 
### 虚析构和纯虚析构
父类指针析构时不会调用子类析构，这时需要虚析构（将父类析构加个virtual），而直接改为纯虚析构则缺少一个函数实现，这时再实现一下实现就行。

纯虚函数不需要实现，而纯虚析构则既需要声明也需要实现。

  > 如果子类没有堆区数据则不会出现不调用析构内存泄漏，这时可以不写虚析构或者纯虚析构。

## 模板
### 函数模板
空模板参数列表，强制调用函数模板
~~~
print<>(a,b);
~~~
都可以调用时，优先调用普通函数。但是当模板函数梗更匹配时调用模板函数。

具体化自定义类型的模板函数
~~~
template<> bool mycaompare(per t1,per t2){
    ...
}
~~~
### 类模板
类模板没有自动类型推导（函数模板可以）
~~~
person p1("jack",16);//error!

person<string,int> p2("jack",16);//good!
~~~

类模板可以有默认参数（函数模板不行）
~~~
template<class Typename ,class Typename=int>
...
person<string> p("jack",999);
~~~
类模板成员函数在调用时创建。
普通类成员函数一开始创建。

类模板成员函数类外实现
~~~
teplate....
person<T1,T2>::person(T1 name,T2 b){
  ...
} //构造
teplate....
person<T1,T2>::show(){
  ...
} 

~~~
